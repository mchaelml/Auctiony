{
  "_args": [
    [
      "@uifabric/merge-styles@https://registry.npmjs.org/@uifabric/merge-styles/-/merge-styles-5.17.1.tgz",
      "C:\\Users\\mchae\\Desktop\\Bacchus-master\\Bacchus"
    ]
  ],
  "_from": "@uifabric/merge-styles@https://registry.npmjs.org/@uifabric/merge-styles/-/merge-styles-5.17.1.tgz",
  "_id": "@uifabric/merge-styles@5.17.1",
  "_inCache": true,
  "_location": "/@uifabric/merge-styles",
  "_phantomChildren": {},
  "_requested": {
    "name": "@uifabric/merge-styles",
    "raw": "@uifabric/merge-styles@https://registry.npmjs.org/@uifabric/merge-styles/-/merge-styles-5.17.1.tgz",
    "rawSpec": "https://registry.npmjs.org/@uifabric/merge-styles/-/merge-styles-5.17.1.tgz",
    "scope": "@uifabric",
    "spec": "https://registry.npmjs.org/@uifabric/merge-styles/-/merge-styles-5.17.1.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/@uifabric/styling",
    "/@uifabric/utilities",
    "/office-ui-fabric-react"
  ],
  "_resolved": "https://registry.npmjs.org/@uifabric/merge-styles/-/merge-styles-5.17.1.tgz",
  "_shasum": "9325817069011efb5f425e0fd163a975d9a12a3c",
  "_shrinkwrap": null,
  "_spec": "@uifabric/merge-styles@https://registry.npmjs.org/@uifabric/merge-styles/-/merge-styles-5.17.1.tgz",
  "_where": "C:\\Users\\mchae\\Desktop\\Bacchus-master\\Bacchus",
  "bugs": {
    "url": "https://github.com/OfficeDev/office-ui-fabric-react/issues"
  },
  "dependencies": {
    "tslib": "^1.7.1"
  },
  "description": "Office UI Fabric style loading utilities.",
  "devDependencies": {
    "@types/jest": "21.1.8",
    "office-ui-fabric-react-tslint": ">=5.0.0 <6.0.0"
  },
  "disabledTasks": [
    "copy",
    "karma",
    "sass"
  ],
  "homepage": "https://github.com/OfficeDev/office-ui-fabric-react#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "name": "@uifabric/merge-styles",
  "optionalDependencies": {},
  "readme": "# [merge-styles](http://dev.office.com/fabric)\r\n\r\nThe `merge-styles` library provides utilities for loading styles through javascript. It is designed to make it simple to style components through javascript. It generates css classes, rather than using inline styling, to ensure we can use css features like pseudo selectors (:hover) and parent/child selectors (media queries).\r\n\r\nThe library was built for speed and size; the entire package is 2.62k gzipped. It has no dependencies other than `tslib`.\r\n\r\nSimple usage:\r\n```\r\nimport { mergeStyles, mergeStyleSet } from '@uifabric/merge-styles';\r\n\r\n// Produces 'css-0' class name which can be used anywhere\r\nmergeStyles({ background: 'red' });\r\n\r\n// Produces a class map for a bunch of rules all at once\r\nmergeStyleSet({\r\n  root: { background: 'red' },\r\n  child: { background: 'green' }\r\n});\r\n\r\n// Returns { root: 'root-0', child: 'child-1' }\r\n```\r\n\r\nBoth utilities behave similar to a deep Object.assign; you can collapse many objects down into one class name or class map.\r\n\r\nThe basic idea is to provide tools which can take in one or more css styling objects representing the styles for a given element, and return a single class name. If the same set of styling is passed in, the same name returns and nothing is re-registered.\r\n\r\n## Motivation\r\n\r\nDefining rules at runtime has a number of benefits over traditional build time staticly produced css:\r\n\r\n* Only register classes that are needed, when they're needed, reducing the overall selector count and improving TTG.\r\n\r\n* Dynamically create new class permutations based on contextual theming requirements. (Use a different theme inside of a DIV without downloading multiple copies of the css rule definitions.)\r\n\r\n* Use JavaScript to define the class content (using utilities like color converters, or reusing constant numbers becomes possible.)\r\n\r\n* Allow control libraries to merge customized styling in with their rules, avoiding complexities like css selector specificity.\r\n\r\n* Simplify RTL processing; lefts become rights in RTL, in the actual rules. No complexity like `html[dir=rtl]` prefixes necessary, which alleviates unexpected specificity bugs. (You can use `/* noflip */` comments to avoid flipping if needed.)\r\n\r\n* Reduce bundle size. Automatically handles vendor prefixing, unit providing, RTL flipping, and margin/padding expansion (e.g. margin will automatically expand out to margin TRBL, so that we avoid specificity problems when merging things together.)\r\n\r\n* Reduce the build time overhead of running through CSS preprocessors.\r\n\r\n* TypeScript type safety; spell \"background\" wrong and get build breaks.\r\n\r\n## What tradeoffs are there? Are there downsides to using JavaScript to process styling?\r\n\r\nIn static solutions, there is very little runtime evaluation required; everything is injected as-is. Things like auto prefixing and language specific processing like sass mixins are all evaluated at build time.\r\n\r\nIn runtime styling, much of this is evaluated in the browser, so you are paying a cost in doing this. However, with performance optimizations like memoization, you can minimize this quite a bit, and you gain all of the robustness enumerated above.\r\n\r\n# API\r\n\r\nThe api surfaces consists of 3 methods and a handful of interfaces:\r\n\r\n`mergeStyles(..args[]: IStyle[]): string` - Takes in one or more style objects, merges them in the right order, and produces a single css class name which can be injected into any component.\r\n\r\n`mergeStyleSet(...args[]: IStyleSet[]): { [key: string]: string }` - Takes in one or more style set objects, each consisting of a set of areas, each which will produce a class name. Using this is analogous to calling mergeStyles for each property in the object, but ensures we maintain the set ordering when multiple style sets are merged.\r\n\r\n`concatStyleSet(...args[]: IStyleSet[]): IStyleSet` - In some cases you simply need to combine style sets, without actually generating class names (it is costs in performance to generate class names.) This tool returns a single set merging many together.\r\n\r\n## Vocabulary\r\n\r\nA **style object** represents the collection of css rules, except that the names are camelCased rather than kebab-cased. Example:\r\n\r\n```tsx\r\nlet style = {\r\n  backgroundColor: 'red',\r\n  left: 42\r\n};\r\n```\r\n\r\nAdditionally, **style objects** can contain selectors under the `selectors` property:\r\n\r\n```tsx\r\nlet style = {\r\n  backgroundColor: 'red',\r\n  selectors: {\r\n    ':hover': {\r\n      backgroundColor: 'blue';\r\n    },\r\n    '.parent &': { /* parent selector */ },\r\n    '& .child': { /* child selector */ }\r\n  }\r\n};\r\n```\r\n\r\nA **style set** represents a map of area to style object. When building a component, you need to generate a class name for each element that requires styling. You would defint this in a **style set**.\r\n\r\n```tsx\r\nlet styleSet = {\r\n  root: { background: 'red' },\r\n  button: { margin: 42 }\r\n}\r\n```\r\n\r\n## Basic usage\r\n\r\nWhen building a component, you will need a **style set** map of class names to inject into your elements' class attributes.\r\n\r\nThe recommended pattern is to provide the classnames in a separate function, typically in a separate file `ComponentName.classNames.ts`.\r\n\r\n```tsx\r\nimport { IStyle, mergeStyleSets } from '@uifabric/merge-styles';\r\n\r\nexport interface IComponentClassNames {\r\n  root: string;\r\n  button: string;\r\n  buttonIcon: string;\r\n}\r\n\r\nexport const getClassNames = (): IComponentClassNames => {\r\n  return mergeStyleSets({\r\n    root: {\r\n        background: 'red'\r\n      }\r\n    ),\r\n\r\n    button: {\r\n      backgroundColor: 'green',\r\n    },\r\n\r\n    buttonIcon: {\r\n      margin: 10\r\n    }\r\n  });\r\n};\r\n```\r\n\r\nThe class map can then be used in a component:\r\n\r\n```tsx\r\nimport { getClassNames } from './MyComponent.classNames';\r\n\r\nexport const MyComponent = () => {\r\n  let { root, button, buttonIcon } = getClassNames();\r\n\r\n  return (\r\n    <div className={ root }>\r\n      <button className={ button }>\r\n        <i className={ buttonIcon } />\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n## Selectors\r\n\r\n### Basic pseudo-selectors (:hover, :active, etc)\r\n\r\nCustom selectors can be defined within `IStyle` definitions under the `selectors` section:\r\n\r\n```tsx\r\n{\r\n  background: 'red',\r\n  selectors: {\r\n    ':hover': {\r\n      background: 'green'\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nBy default, the rule will be appended to the current selector scope. That is, in the above scenario, there will be 2 rules inserted when using `mergeStyles`:\r\n\r\n```css\r\n.css-0 { background: red; }\r\n.css-0:hover { background: green; }\r\n```\r\n### Parent/child selectors\r\n\r\nIn some cases, you may need to use parent or child selectors. To do so, you can define a selector from scratch and use the `&` character to represent the generated class name. When using the `&`, the current scope is ignored. Example:\r\n\r\n```tsx\r\n{\r\n  selectors: {\r\n    // selector relative to parent\r\n    '.ms-Fabric--isFocusVisible &': {\r\n      background: 'red'\r\n    }\r\n    // selector for child\r\n    '& .child' {\r\n      background: 'green'\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis would register the rules:\r\n\r\n```css\r\n.ms-Fabric--isFocusVisible .css-0 { background: red; }\r\n.css-0 .child { background: green; }\r\n```\r\n\r\n### Global selectors\r\n\r\nWhile we suggest avoiding global selectors, there are some cases which make sense to register things globally. Keep in mind that global selectors can't be guaranteed unique and may suffer from specificity problems and versioning issues in the case that two different versions of your library get rendered on the page.\r\n\r\nTo register a selector globally, wrap it in a `:global()` wrapper:\r\n\r\n```tsx\r\n{\r\n  selectors: {\r\n    ':global(button)': {\r\n      overflow: 'visible'\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Media queries\r\n\r\nMedia queries can be applied via selectors. For example, this style will produce a class which has a red background when above 600px, and green when at or below 600px:\r\n\r\n```tsx\r\nmergeStyles({\r\n  background: 'red',\r\n  selectors: {\r\n    '@media(max-width: 600px)': {\r\n      background: 'green'\r\n    }\r\n  }\r\n});\r\n```\r\n\r\nProduces:\r\n\r\n```css\r\n.css-0 { background: red; }\r\n\r\n@media(max-width: 600px) {\r\n  .css-0 { background: green; }\r\n}\r\n```\r\n\r\n### Referencing child elements within the mergeStyleSets scope\r\n\r\nOne important concept about `mergeStyleSets` is that it produces a map of class names for the given elements:\r\n\r\n```tsx\r\nmergeStyleSets({\r\n  root: { background: 'red' }\r\n  thumb: { background: 'green' }\r\n});\r\n```\r\n\r\nProduces:\r\n\r\n```css\r\n.root-0 { background: red; }\r\n.thumb-1 { background: green; }\r\n```\r\n\r\nIn some cases, you may need to alter a child area by interacting with the parent. For example, when the parent is hovered, change the child background. You can reference the areas defined in the style set using $ tokens:\r\n\r\n```tsx\r\nmergeStyleSets({\r\n  root: {\r\n    selectors: {\r\n      ':hover $thumb': { background: 'lightgreen' }\r\n    }\r\n   }\r\n  thumb: { background: 'green' }\r\n});\r\n```\r\n\r\nThe `$thumb` reference in the selector on root will be replaced with the class name generated for thumb.\r\n\r\n## Custom class names\r\n\r\nBy default when using `mergeStyles`, class names that are generated will use the prefix `css-` followed by a number, creating unique rules where needed. For example, the first class name produced will be 'css-0'.\r\n\r\nWhen using `mergeStyleSets`, class names automatically use the area name as the prefix.\r\n\r\nMerging rules like:\r\n\r\n```ts\r\nmergeStyleSets({ a: { ... }, b: { ... } })\r\n```\r\n\r\nWill produce the class name map:\r\n\r\n```ts\r\n{ a: 'a-0', b: 'b-1' }\r\n```\r\n\r\nIf you'd like to override the default prefix in either case, you can pass in a `displayName` to resolve this:\r\n\r\n```tsx\r\n{\r\n  displayName: 'MyComponent',\r\n  background: 'red'\r\n}\r\n```\r\n\r\nThis generates:\r\n\r\n```css\r\n.MyComponent-0 { background: red; }\r\n```\r\n\r\n## Managing conditionals and states\r\n\r\nStyle objects can be represented by a simple object, but also can be an array of the objects. The merge functions will handle arrays and merge things together in the given order. They will also ignore falsey values, allowing you to conditionalize the results.\r\n\r\nIn the following example, the root class generated will be different depending on the `isToggled` state:\r\n\r\n```tsx\r\nexport const getClassNames = (\r\n  isToggled: boolean\r\n): IComponentClassNames => {\r\n\r\n  return mergeStyleSet({\r\n    root: [\r\n      {\r\n        background: 'red'\r\n      },\r\n      isToggled && {\r\n        background: 'green'\r\n      }\r\n    ]\r\n  })\r\n};\r\n```\r\n\r\n## RTL support\r\n\r\nBy default, nearly all of the major rtl-sensitive CSS properties will be auto flipped when the dir=\"rtl\" flag is present on the `HTML` tag of the page.\r\n\r\nThere are some rare scenarios (linear-gradients, etc) which are not flipped, for the sake of keeping the bundle size to a minimum. If there are missing edge cases, please submit a PR to address.\r\n\r\nIn rare condition where you want to avoid auto flipping, you can annotate the rule with the `@noflip` directive:\r\n\r\n```tsx\r\nmergeStyles({\r\n  left: '42px @noflip'\r\n});\r\n```\r\n\r\n## Optimizing for performance\r\n\r\nResolving the class names on every render can be an unwanted expense especially in hot spots where things are rendered frequently. To optimize, we recommend 2 guidelines:\r\n\r\n1. For your `getClassNames` function, flatten all input parameters into simple immutable values. This helps the `memoizeFunction` utility to cache the results based on the input.\r\n\r\n2. Use the `memoizeFunction` function from the `@uifabric/utilities` package to cache the results, given a unique combination of inputs. Example:\r\n\r\n```tsx\r\nimport { memoizeFunction } from '@uifabric/utilities';\r\n\r\nexport const getClassNames = memoizeFunction((\r\n  isToggled: boolean\r\n) => {\r\n  return mergeStyleSet({\r\n    // ...\r\n  });\r\n});\r\n```\r\n\r\n## Registering fonts\r\n\r\nRegistering font faces example:\r\n\r\n```tsx\r\nimport { fontFace } from '@uifabric/merge-styles';\r\n\r\nfontFace({\r\n  fontFamily: `\"Segoe UI\"`,\r\n  src: `url(\"//cdn.com/fontface.woff2) format(woff2)`,\r\n  fontWeight: \"normal\"\r\n});\r\n```\r\n\r\nNote that in cases like `fontFamily` you may need to embed quotes in the string as shown above.\r\n\r\n## Registering keyframes\r\n\r\nRegistering animation keyframes example:\r\n\r\n```tsx\r\nimport { keyframes, mergeStyleSets } from '@uifabric/merge-styles';\r\n\r\nlet fadeIn = keyframes({\r\n  \"from\": {\r\n    opacity: 0\r\n  },\r\n  \"to\": {\r\n    opacity: 1\r\n  }\r\n});\r\n\r\nexport const getClassNames = () => {\r\n  return mergeStyleSets({\r\n    root: {\r\n      animationName: fadeIn\r\n    }\r\n  });\r\n};\r\n```\r\n\r\n## Server-side rendering\r\n\r\nYou can import `renderStatic` method from the `/lib/server` entry to render content and extract the css rules that would have been registered, as a string.\r\n\r\nExample:\r\n\r\n```tsx\r\nimport { renderStatic } from '@uifabric/merge-styles/lib/server';\r\n\r\nlet { html, css } = renderStatic(() => {\r\n  return ReactDOM.renderToString(...);\r\n});\r\n```\r\n\r\nCaveats for server-side rendering (TODOs):\r\n\r\n* Currently font face definitions and keyframes won't be included in the result.\r\n\r\n* Using the `memoizeFunction` utility may short circuit calling merge-styles APIs to register styles, which may cause the helper here to skip returning css. This can be fixed, but it is currently a known limitation.\r\n\r\n* Until all Fabric components use the merge-styles library, this will only return a subset of the styling. Also a known limitation and work in progress.\r\n\r\n* The rehydration logic has not yet been implemented, so we may run into issues when you rehydrate.\r\n\r\n* Only components which USE mergeStyles will have their css included. In Fabric, not all components have been converted from using SASS yet.\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/OfficeDev/office-ui-fabric-react.git"
  },
  "scripts": {
    "build": "node ../../scripts/build.js",
    "clean": "node ../../scripts/clean.js",
    "start-test": "node ../../scripts/start-test.js"
  },
  "sideEffects": false,
  "typings": "lib-es2015/index.d.ts",
  "version": "5.17.1"
}
