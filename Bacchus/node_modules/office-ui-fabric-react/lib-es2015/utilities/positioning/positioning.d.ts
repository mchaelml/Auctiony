import { DirectionalHint } from '../../common/DirectionalHint';
import { Rectangle as FullRectangle, IRectangle } from '../../Utilities';
import { IPositionDirectionalHintData, IPositionedData, IPoint, ICalloutPositionedInfo, ICalloutBeakPositionedInfo, IPositionProps, ICalloutPositionProps, RectangleEdge, IRelativePositions } from './positioning.types';
export declare class Rectangle extends FullRectangle {
    [key: string]: number | boolean | any;
}
/**
 * Do not call methods from this directly, use either positionCallout or positionElement or make another function that
 * utilizes them.
 */
export declare namespace positioningFunctions {
    interface IElementPosition {
        elementRectangle: Rectangle;
        targetEdge: RectangleEdge;
        alignmentEdge: RectangleEdge | undefined;
    }
    interface IElementPositionInfo extends IElementPosition {
        targetRectangle: Rectangle;
    }
    type PartialIRectangle = Partial<IRectangle>;
    interface IPartialIRectangle extends PartialIRectangle {
        [key: string]: number | undefined;
    }
    function _calculateActualBeakWidthInPixels(beakWidth: number): number;
    /**
     * Returns the appropriate IPositionData based on the props altered for RTL.
     * If directionalHintForRTL is passed in that is used if the page is RTL.
     * If a directionalHint is specified and no directionalHintForRTL is available and the page is RTL the hint will be flipped.
     * For instance bottomLeftEdge would become bottomRightEdge.
     * If there is no directionalHint passed in bottomAutoEdge is chosen automatically.
     *
     * @param {IPositionProps} props
     * @returns {IPositionDirectionalHintData}
     */
    function _getPositionData(directionalHint?: DirectionalHint, directionalHintForRTL?: DirectionalHint, previousPositions?: IPositionedData): IPositionDirectionalHintData;
    function _positionElementWithinBounds(elementToPosition: Rectangle, target: Rectangle, bounding: Rectangle, positionData: IPositionDirectionalHintData, gap: number, directionalHintFixed?: boolean, coverTarget?: boolean): IElementPosition;
    function _finalizeBeakPosition(elementPosition: IElementPosition, positionedBeak: Rectangle): ICalloutBeakPositionedInfo;
    function _positionBeak(beakWidth: number, elementPosition: IElementPositionInfo): Rectangle;
    function _getRectangleFromElement(element: Element): Rectangle;
    function _getRectangleFromIRect(rect: IRectangle): Rectangle;
    function _getTargetRect(bounds: Rectangle, target: Element | MouseEvent | IPoint | undefined): Rectangle;
    /**
     * If max height is less than zero it returns the bounds height instead.
     */
    function _getMaxHeightFromTargetRectangle(targetRectangle: Rectangle, targetEdge: DirectionalHint, gapSpace: number, bounds: Rectangle): number;
    function _positionElementRelative(props: IPositionProps, hostElement: HTMLElement, elementToPosition: HTMLElement, previousPositions?: IPositionedData): IElementPositionInfo;
    function _finalizePositionData(positionedElement: IElementPosition, hostElement: HTMLElement): IPositionedData;
    function _positionElement(props: IPositionProps, hostElement: HTMLElement, elementToPosition: HTMLElement, previousPositions?: IPositionedData): IPositionedData;
    function _positionCallout(props: ICalloutPositionProps, hostElement: HTMLElement, callout: HTMLElement, previousPositions?: ICalloutPositionedInfo): ICalloutPositionedInfo;
    /**
     * @deprecated Do not use, this will be removed in 6.0
     * use either _positionCallout or _positionElement.
     * @export
     * @param {IPositionProps} props
     * @param {HTMLElement} hostElement
     * @param {HTMLElement} elementToPosition
     * @returns
     */
    function _getRelativePositions(props: IPositionProps, hostElement: HTMLElement, elementToPosition: HTMLElement): IRelativePositions;
}
/**
 * @deprecated Do not use, this will be removed in 6.0.
 * Use either positionElement, or positionCallout
 *
 * @export
 * @param {IPositionProps} props
 * @param {HTMLElement} hostElement
 * @param {HTMLElement} calloutElement
 * @returns
 */
export declare function getRelativePositions(props: IPositionProps, hostElement: HTMLElement, calloutElement: HTMLElement): IRelativePositions;
/**
 * Used to position an element relative to the given positioning props.
 * If positioning has been completed before, previousPositioningData
 * can be passed to ensure that the positioning element repositions based on
 * its previous targets rather than starting with directionalhint.
 *
 * @export
 * @param {IPositionProps} props
 * @param {HTMLElement} hostElement
 * @param {HTMLElement} elementToPosition
 * @param {IPositionedData} previousPositions
 * @returns
 */
export declare function positionElement(props: IPositionProps, hostElement: HTMLElement, elementToPosition: HTMLElement, previousPositions?: IPositionedData): IPositionedData;
export declare function positionCallout(props: IPositionProps, hostElement: HTMLElement, elementToPosition: HTMLElement, previousPositions?: ICalloutPositionedInfo): ICalloutPositionedInfo;
/**
 * Get's the maximum height that a rectangle can have in order to fit below or above a target.
 * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder
 * of the target given.
 * If no bounds are provided then the window is treated as the bounds.
 */
export declare function getMaxHeight(target: Element | MouseEvent | IPoint, targetEdge: DirectionalHint, gapSpace?: number, bounds?: IRectangle): number;
